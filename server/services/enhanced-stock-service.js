/**
 * Enhanced Stock Management Service
 * Handles shared stock across main products and platform variants
 */

const logger = require("../utils/logger");
const {
  MainProduct,
  PlatformVariant,
  InventoryMovement,
  StockReservation,
  sequelize,
} = require("../models");
const { Op } = require("sequelize");

class EnhancedStockService {
  /**
   * Get current stock status for a main product
   */
  async getStockStatus(mainProductId) {
    try {
      const mainProduct = await MainProduct.findByPk(mainProductId, {
        include: [
          {
            model: PlatformVariant,
            as: "platformVariants",
            where: { status: "active" },
            required: false,
          },
          {
            model: StockReservation,
            as: "stockReservations",
            where: { status: "active" },
            required: false,
          },
        ],
      });

      if (!mainProduct) {
        throw new Error("Main product not found");
      }

      const totalReserved = await this.calculateReservedStock(mainProductId);
      const availableStock = mainProduct.stockQuantity - totalReserved;

      return {
        mainProductId,
        totalStock: mainProduct.stockQuantity,
        reservedStock: totalReserved,
        availableStock,
        minStockLevel: mainProduct.minStockLevel,
        isLowStock: availableStock <= mainProduct.minStockLevel,
        platformVariants: mainProduct.platformVariants.map((variant) => ({
          id: variant.id,
          platform: variant.platform,
          platformSku: variant.platformSku,
          isPublished: variant.isPublished,
          syncStatus: variant.syncStatus,
        })),
        lastStockUpdate: mainProduct.lastStockUpdate,
      };
    } catch (error) {
      logger.error("Error getting stock status:", error);
      throw error;
    }
  }

  /**
   * Calculate total reserved stock for a main product
   */
  async calculateReservedStock(mainProductId) {
    try {
      const result = await StockReservation.sum("quantity", {
        where: {
          mainProductId,
          status: "active",
          expiresAt: { [Op.gt]: new Date() },
        },
      });

      return result || 0;
    } catch (error) {
      logger.error("Error calculating reserved stock:", error);
      return 0;
    }
  }

  /**
   * Update stock for a main product
   */
  async updateStock(
    mainProductId,
    newQuantity,
    reason = "Manual update",
    userId = null,
    metadata = {}
  ) {
    const transaction = await sequelize.transaction();

    try {
      const mainProduct = await MainProduct.findByPk(mainProductId, {
        transaction,
      });

      if (!mainProduct) {
        throw new Error("Main product not found");
      }

      const oldQuantity = mainProduct.stockQuantity;
      const changeAmount = newQuantity - oldQuantity;

      // Update main product stock
      await mainProduct.update(
        {
          stockQuantity: newQuantity,
          lastStockUpdate: new Date(),
        },
        { transaction }
      );

      // Record inventory movement
      await InventoryMovement.create(
        {
          mainProductId,
          movementType: changeAmount > 0 ? "IN_STOCK" : "OUT_STOCK",
          quantity: Math.abs(changeAmount),
          previousQuantity: oldQuantity,
          newQuantity,
          reason,
          userId,
          metadata: {
            ...metadata,
            autoGenerated: false,
            stockUpdate: true,
          },
        },
        { transaction }
      );

      // Check if stock is now below minimum level
      const reservedStock = await this.calculateReservedStock(mainProductId);
      const availableStock = newQuantity - reservedStock;

      if (availableStock <= mainProduct.minStockLevel) {
        await this.handleLowStockAlert(
          mainProduct,
          availableStock,
          transaction
        );
      }

      // Sync stock with platform variants if needed
      await this.syncStockWithPlatforms(mainProductId, transaction);

      await transaction.commit();

      logger.info(
        `Stock updated for main product ${mainProductId}: ${oldQuantity} â†’ ${newQuantity}`
      );

      return await this.getStockStatus(mainProductId);
    } catch (error) {
      await transaction.rollback();
      logger.error("Error updating stock:", error);
      throw error;
    }
  }

  /**
   * Reserve stock for orders or platform variants
   */
  async reserveStock(
    mainProductId,
    quantity,
    reason = "Order reservation",
    expiresAt = null,
    metadata = {}
  ) {
    const transaction = await sequelize.transaction();

    try {
      // Check available stock
      const stockStatus = await this.getStockStatus(mainProductId);

      if (stockStatus.availableStock < quantity) {
        throw new Error(
          `Insufficient stock. Available: ${stockStatus.availableStock}, Requested: ${quantity}`
        );
      }

      // Default expiration: 30 minutes
      const defaultExpiration = new Date(Date.now() + 30 * 60 * 1000);
      const expirationDate = expiresAt || defaultExpiration;

      // Create stock reservation
      const reservation = await StockReservation.create(
        {
          mainProductId,
          quantity,
          reason,
          expiresAt: expirationDate,
          status: "active",
          metadata,
        },
        { transaction }
      );

      // Record inventory movement
      await InventoryMovement.create(
        {
          mainProductId,
          movementType: "RESERVED",
          quantity,
          reason: `Stock reserved: ${reason}`,
          metadata: {
            ...metadata,
            reservationId: reservation.id,
            expiresAt: expirationDate,
          },
        },
        { transaction }
      );

      await transaction.commit();

      logger.info(
        `Stock reserved for main product ${mainProductId}: ${quantity} units`
      );

      return reservation;
    } catch (error) {
      await transaction.rollback();
      logger.error("Error reserving stock:", error);
      throw error;
    }
  }

  /**
   * Release reserved stock
   */
  async releaseReservation(reservationId, reason = "Reservation released") {
    const transaction = await sequelize.transaction();

    try {
      const reservation = await StockReservation.findByPk(reservationId, {
        transaction,
      });

      if (!reservation) {
        throw new Error("Reservation not found");
      }

      if (reservation.status !== "active") {
        throw new Error("Reservation is not active");
      }

      // Update reservation status
      await reservation.update(
        {
          status: "released",
          releasedAt: new Date(),
        },
        { transaction }
      );

      // Record inventory movement
      await InventoryMovement.create(
        {
          mainProductId: reservation.mainProductId,
          movementType: "RELEASED",
          quantity: reservation.quantity,
          reason,
          metadata: {
            reservationId: reservation.id,
            originalReason: reservation.reason,
          },
        },
        { transaction }
      );

      await transaction.commit();

      logger.info(`Stock reservation released: ${reservationId}`);

      return await this.getStockStatus(reservation.mainProductId);
    } catch (error) {
      await transaction.rollback();
      logger.error("Error releasing reservation:", error);
      throw error;
    }
  }

  /**
   * Process stock movement (sale, return, adjustment)
   */
  async processStockMovement(
    mainProductId,
    movementType,
    quantity,
    reason,
    userId = null,
    metadata = {}
  ) {
    const transaction = await sequelize.transaction();

    try {
      const mainProduct = await MainProduct.findByPk(mainProductId, {
        transaction,
      });

      if (!mainProduct) {
        throw new Error("Main product not found");
      }

      const oldQuantity = mainProduct.stockQuantity;
      let newQuantity;

      switch (movementType) {
        case "IN_STOCK":
          newQuantity = oldQuantity + quantity;
          break;
        case "OUT_STOCK":
        case "SALE":
          // Check available stock before processing
          const availableStock = await this.getAvailableStock(mainProductId);
          if (availableStock < quantity) {
            throw new Error(
              `Insufficient available stock. Available: ${availableStock}, Requested: ${quantity}`
            );
          }
          newQuantity = oldQuantity - quantity;
          break;
        case "ADJUSTMENT":
          newQuantity = quantity; // Direct set to new quantity
          break;
        default:
          throw new Error(`Unknown movement type: ${movementType}`);
      }

      // Update main product stock
      await mainProduct.update(
        {
          stockQuantity: newQuantity,
          lastStockUpdate: new Date(),
        },
        { transaction }
      );

      // Record inventory movement
      await InventoryMovement.create(
        {
          mainProductId,
          movementType,
          quantity:
            movementType === "ADJUSTMENT"
              ? Math.abs(newQuantity - oldQuantity)
              : quantity,
          previousQuantity: oldQuantity,
          newQuantity,
          reason,
          userId,
          metadata,
        },
        { transaction }
      );

      // Sync with platforms if this affects published variants
      await this.syncStockWithPlatforms(mainProductId, transaction);

      await transaction.commit();

      logger.info(
        `Stock movement processed for ${mainProductId}: ${movementType} ${quantity}`
      );

      return await this.getStockStatus(mainProductId);
    } catch (error) {
      await transaction.rollback();
      logger.error("Error processing stock movement:", error);
      throw error;
    }
  }

  /**
   * Get available stock (total - reserved)
   */
  async getAvailableStock(mainProductId) {
    try {
      const mainProduct = await MainProduct.findByPk(mainProductId);
      if (!mainProduct) return 0;

      const reservedStock = await this.calculateReservedStock(mainProductId);
      return mainProduct.stockQuantity - reservedStock;
    } catch (error) {
      logger.error("Error getting available stock:", error);
      return 0;
    }
  }

  /**
   * Sync stock with platform variants
   */
  async syncStockWithPlatforms(mainProductId, transaction = null) {
    try {
      const variants = await PlatformVariant.findAll({
        where: {
          mainProductId,
          isPublished: true,
          syncStatus: "success",
        },
        transaction,
      });

      const availableStock = await this.getAvailableStock(mainProductId);

      // TODO: Implement platform-specific stock sync
      // This would call each platform's API to update stock levels
      for (const variant of variants) {
        logger.info(
          `Would sync stock for ${variant.platform}: ${variant.platformSku} = ${availableStock}`
        );

        // Update sync status to indicate stock update is needed
        await variant.update(
          {
            syncStatus: "pending",
            lastSyncAt: new Date(),
          },
          { transaction }
        );
      }

      return true;
    } catch (error) {
      logger.error("Error syncing stock with platforms:", error);
      return false;
    }
  }

  /**
   * Handle low stock alerts
   */
  async handleLowStockAlert(mainProduct, availableStock, transaction = null) {
    try {
      logger.warn(
        `Low stock alert for ${mainProduct.baseSku}: ${availableStock} units remaining`
      );

      // TODO: Implement notification system
      // Could send email, SMS, or create notifications in the system

      return true;
    } catch (error) {
      logger.error("Error handling low stock alert:", error);
      return false;
    }
  }

  /**
   * Get stock history for a main product
   */
  async getStockHistory(mainProductId, limit = 50, offset = 0) {
    try {
      const movements = await InventoryMovement.findAll({
        where: { mainProductId },
        order: [["createdAt", "DESC"]],
        limit,
        offset,
        include: [
          {
            model: MainProduct,
            as: "mainProduct",
            attributes: ["baseSku", "name"],
          },
        ],
      });

      const total = await InventoryMovement.count({
        where: { mainProductId },
      });

      return {
        movements,
        pagination: {
          total,
          limit,
          offset,
          hasMore: offset + limit < total,
        },
      };
    } catch (error) {
      logger.error("Error getting stock history:", error);
      throw error;
    }
  }

  /**
   * Clean up expired reservations
   */
  async cleanupExpiredReservations() {
    try {
      const expiredReservations = await StockReservation.findAll({
        where: {
          status: "active",
          expiresAt: { [Op.lt]: new Date() },
        },
      });

      for (const reservation of expiredReservations) {
        await this.releaseReservation(
          reservation.id,
          "Automatic cleanup - expired"
        );
      }

      logger.info(
        `Cleaned up ${expiredReservations.length} expired reservations`
      );
      return expiredReservations.length;
    } catch (error) {
      logger.error("Error cleaning up expired reservations:", error);
      return 0;
    }
  }

  /**
   * Get bulk stock status for multiple products
   */
  async getBulkStockStatus(mainProductIds) {
    try {
      const results = await Promise.all(
        mainProductIds.map((id) =>
          this.getStockStatus(id).catch((error) => ({
            id,
            error: error.message,
          }))
        )
      );

      return results;
    } catch (error) {
      logger.error("Error getting bulk stock status:", error);
      throw error;
    }
  }
}

module.exports = new EnhancedStockService();
